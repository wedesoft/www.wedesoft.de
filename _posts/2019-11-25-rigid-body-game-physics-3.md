---
layout: post
title: Rigid body game physics 3
category: simulation
---

<a href="/simulation/2019/10/24/rigid-body-game-physics/">part 1</a>
<a href="/simulation/2019/11/13/rigid-body-game-physics-2/">part 2</a>
<a href="/simulation/2019/11/25/rigid-body-game-physics-3/">part 3</a>
<a href="/simulation/2019/11/29/rigid-body-game-physics-4/">part 4</a>
<a href="/simulation/2019/12/01/rigid-body-game-physics-5/">part 5</a>
<a href="/simulation/2019/12/03/rigid-body-game-physics-6/">part 6</a>

**Update:** See <a href="/simulation/2024/09/26/jolt-physics-engine/">Getting started with the Jolt Physics Engine</a>

The following article is based on [Hubert Eichner's article on inequality constraints][1].

## Inequality Constraints for Resting Contacts
Contact points (resting contacts) are represented as inequality constraints.
In contrast to a joint, a resting contact can only create repellent forces and no attracting forces.
Similar to a joint constraint, the resting contact is represented using a function *C(y(t))*.
Here *C* is one-dimensional and it is basically the distance of the two objects at the contact point.
The inequality constraint of the resting contact is
{% latex %}
$\dot{C}=Ju+b\ge 0$
{% endlatex %}
with the matrix *J* having one row and twelve columns.
Instead of anchor points, one uses vectors *ri* and *rj* from the center of each object to the contact point.
Using the contact normal *n* the inequality constraint becomes:
{% latex %}
$\dot{C}= n^\top (v_j+\omega_j\times r_j-v_i-\omega_i\times r_i)+b\ge 0$
{% endlatex %}
The rotational component can be simplified as shown below:
{% latex %}
$n^\top (\omega_i \times r_i) = -n^\top (r_i \times \omega_i) = -n^\top r_i^\times \omega_i = (r_i^\times n)^\top \omega_i = (r_i \times n)^\top \omega_i$
{% endlatex %}
Thus the linear components of *J* are
{% latex %}
$J_{lin}^i = -n^\top$, $J_{lin}^j = n^\top$
{% endlatex %}
And the angular components of *J* are
{% latex %}
$J_{ang}^i = -(r_i \times n)^\top$, $J_{ang}^j = (r_j \times n)^\top$
{% endlatex %}
The correction term depends on the distance *d*.
I.e. if the distance is negative, a correction is required so that the objects do not penetrate each other any more.
{% latex %}
$b = d$
{% endlatex %}

## Sequential Impulses (updated)
The impulses generated by contact constraints and joint constraints are accumulated in a loop.
The (cumulative) *位* obtained for contact constraint furthermore is clipped to be greater or equal to zero.
Note that it has to be the cumulative value which is clipped.
The algorithm for solving the joint and contact constraints becomes:

* for each iteration
    * for each joint
        1. compute Jacobian *J* and correction vector *b*
        1. predict speed *u*
        1. compute *位*
        1. compute the impulse *P*
        1. add *P* to accumulated impulses of the two objects
    * for each resting contact
        1. subtract old impulses *P* from previous iteration from accumulated impulses of the two objects
        1. compute Jacobian *J* and correction vector *b*
        1. predict speed *u*
        1. compute new *位* and clip it to be greater or equal to zero
        1. compute the impulse *P*
        1. add *P* to accumulated impulses of the two objects
* use impulses and external forces to perform Runge Kutta integration step

The sequential impulse iterations have to be performed four times when using the Runge-Kutta method.
The value *位* is stored as *Pn* for limiting friction impulses lateron.

![Contact](/pics/contact.gif)

[1]: http://myselph.de/gamePhysics/inequalityConstraints.html
